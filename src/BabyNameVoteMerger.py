import argparse
from pathlib import Path
import csv


def parse_args():
    parser = argparse.ArgumentParser(
        description=(
            "Combine two lists of baby name voting cards (generated by the other script"
            " in this package) and display combined result"
        )
    )
    parser.add_argument("file1", type=Path, help="Path to first CSV file")
    parser.add_argument("file2", type=Path, help="Path to second CSV file")

    return parser.parse_args()


def file_to_dict(file):
    output_dict = {}
    with open(file) as f:
        reader = csv.reader(f)
        next(reader)  # Header line
        for row in reader:
            yes_vote = False
            maybe_vote = False
            no_vote = False

            if bool(row[2].strip()):
                yes_vote = True
            elif bool(row[1].strip()):
                maybe_vote = True
            else:
                no_vote = True

            output_dict[row[0]] = (no_vote, maybe_vote, yes_vote)

    return output_dict


def get_score_array(votes1: dict, votes2: dict):
    results = []

    all_names = set(votes1) | set(votes2)

    for name in sorted(all_names):
        file1_votes = votes1.get(name, (True, False, False))
        file2_votes = votes2.get(name, (True, False, False))

        if (file1_votes[0] is False) and (file2_votes[0] is False):

            result = (
                name,
                file1_votes[1] and file2_votes[1],  # Both maybe
                file1_votes[2] and file2_votes[1],  # File 1 yes
                file1_votes[1] and file2_votes[2],  # File 2 yes
                file1_votes[2] and file2_votes[2],  # Both yes!
            )
            results.append(result)

    return results


def print_separator(width):
    print("=" * width)


def gen_centered_text(text, width, offset=0):
    left_padding = ((width - len(text)) / 2) + offset
    return (" " * int(left_padding)) + text


def print_scores(scores, file1_name, file2_name):
    name_width = 0

    for score in scores:
        if len(score[0]) > name_width:
            name_width = len(score[0])

    display_width = name_width
    display_width += len(file1_name)
    display_width += len(file2_name)
    display_width += len("(BOTH MAYBE)")
    display_width += 3  # Spaces

    print_separator(display_width)
    print(gen_centered_text("BOTH LIKED:", display_width))
    print("")
    for score in scores:
        if score[4]:
            print(score[0])
    print("")

    print_separator(display_width)
    print(gen_centered_text("TO BE CONSIDERED:", display_width))
    print("")
    print((" " * (name_width + 1)) + file1_name + " (BOTH MAYBE) " + file2_name)
    for score in scores:
        if score[4]:
            continue
        elif score[2]:
            curr_row = gen_centered_text(" X", len(file1_name), name_width + 1)
        elif score[1]:
            curr_row = gen_centered_text(
                " X", len("(BOTH_NAMES"), name_width + len(file1_name) + 2
            )
        elif score[3]:
            curr_row = gen_centered_text(
                " X",
                len(file2_name),
                name_width + len(file1_name) + len("(BOTH_NAMES") + 3,
            )
        print(score[0] + curr_row[len(score[0]) :])


def main():
    args = parse_args()
    scores = get_score_array(file_to_dict(args.file1), file_to_dict(args.file2))
    print_scores(scores, args.file1.stem, args.file2.stem)


if __name__ == "__main__":
    main()
